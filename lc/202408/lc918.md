# LC 918: Maximum Sum Circular Subarray

To build an intuition for the resolution of this problem it's useful to highlight some properties of subarray sums.

- When growing a positive sum subarray in an ordinary array, the ideal new item to add to the subarray should be larger than zero.

    { ..., [ 2 ], ...}                      # subarray sum: 2
    { ..., [ 2, 1 ], ...}                   # subarray sum: 3

- If zero, the item is mostly inconsequential, it grows the subarray, but neither increases nor shrinks its sum. It's typically excluded from the boundaries of an otherwise complete positive sum subarray, unless the problem resolution requires the size of the subarray to also be maximalized.

    { ..., [ 2, 1, 0], ... }                # subarray sum: 3

- If the item is rather negative, it grows the subarray, but actually decreases its overall value, which goes counter the objective.

    { ..., [ 2, 1, 0, -1], ... }            # subarray sum: 2

- In either of the latter two situations, the only truly useful purpose of such items is to "bridge" a left positive segment (without nullifying it, i.e. reducing its value to plain zero or less) to a right positive segment, which results in ultimately increasing the entire subarray's value.

          ...left|bridge|right, ...
                 |      |
    { ..., [ 2, 1| 0, -1| 2], ... }         # subarray sum: 4

- The properties laid out above for positive subarrays are equally valid for their negative counterparts, albeit with opposite rules. In negative sum subarrays, items are ideally negative, the zero is still neutral, and positive values are the ones only useful if they bridge negative left and right segments to further minimize the subarray's overall value. One noteworthy clause here is the treatment of zeroes at boundaries, which in negative sums should be the symmetrical opposite of their treatment at boundaries in the positive sums. That is, if it's conventionaly decided that they're included in one, they must symmetrically be rejected in the other, and vice versa.

    { ..., [ -4 ], ...}                     # subarray sum: -4
    { ..., [ -4, 1 ], ...}                  # subarray sum: -3
    { ..., [ -4, 1, 1], ... }               # subarray sum: -2
    { ..., [ -4, 1, 1, 2], ... }            # subarray sum: 0
    { ..., [ -4, 1, 1, 2, -5], ... }        # subarray sum: -5
    { ..., [ -4, 1, 1, 2, -5, 0], ... }     # subarray sum: -5

        ...left| bridge |right, ...
               |        |
    { ..., [ -4| 1, 1, 2| -5, 0], ... }     # subarray sum: -5

- This is useful to understand intuitively when later reasoning about maximum or minimum sums (maxsum or minsum) in circular arrays.

#### Patterns of maxsum (and minsum) subarray in an ordinary array
- In a normal array, a maxsum subarray can split the original array in at most 3 parts. Here are the possible arrangements:

- Case 1: The sum subarray takes up the entire array (no split):

    {[ Max ]}

- Case 2: The subarray begins somewhere *after* the head and goes on to the tail of the array.

    { head..., [ Max ]}

- Case 3: The subarray starts at the head of the array and stops somewhere before the last item.

    {[ Max ], ...last }

- Case 4: The subarray starts after the head and stops before the last item.

    { head..., [ Max ], ...last }

In any of these scenarios it's relatively easy to calculate the sum using the classic Kadane's approach.

#### Max sum subarray in a circular array
If we're told that the array is circular, however, there's one new and immediately challenging possible arrangement.

- Case 5: The subarray starts somewhere before the last item and ends after the head, but before its starting position.

    { [<-> head ... Max ], ...middle..., [ Max ... last <->] }

Two key points are relevant when building an intuition to the solution for this latter situation:
- First, it's still possible to calculate either the minsum or maxsum of the circular array using classic Kadane.
- Second, in the case of circular arrays, whatever value is left out of either subarray, it belongs to the other. This second point requires a more elaborate proof.

### Proof
- Consider the following situation in a circular array

    {[    A    ][     Max    ][      B     ]}

- If `Max` is the maxsum subarray, it automatically implies that `A` and `B` are individually negative.
- If `Max` is the maxsum subarray, we want to prove that `A+B` forms a corresponding minsum subarray, which we'll call `Min`.
- For `B` to be the complementary of `A` in `Min`, `sum(Min) <= sum(A)` and `sum(Min) <= sum(B)`. That is, if the segment represented by `B` is negative, connecting it to `A` must result in a new segment whose value is either the same or less than `B`.
- If this was not the case, it would imply that `A` is positive and should actually be made a part of `Max`, thus increasing the latter's value.
- Likewise, if `A` is established as negative, adjoining it to `B` to form a minsum segment would imply that `B` is either zero or negative. If `B` was positive, it would only makes sense to adjoin it to `Max`.
- It follows then that if we're given `Max`, we can derive `Min`. And if we're given `Min` we can infer `Max`.

The above proof works equally well if the positions of `Max`, and `Min` are swapped. That is, the latter is now at the center while the former is now made up of the head and tail segments.

    {[    A    ][     Min    ][      B     ]}

- Then, `Max=A+B` becomes the maxsum subarray (in a circular array).

### Tying things together
### Proof that we don't need two passes
- One particular aspect of the property to watch out for is that for any array where there are positive and negative values there can only be one either maxsum or minsum inner subarray. There cannot be both. If the inner subarray is a maxsum, then the `prefix + suffix` will form the minsum and vice versa.

    {[    prefix    ][     inner    ][      suffix     ]}
    {[     min      ][      max     ][       min       ]}
    {[     max      ][      min     ][       max       ]}

- There will also be two candidates to test for inner subarray, one for the maxsum and one for the minsum. Eventually, one will be revealed as part of the surrounding `prefix+suffix` segment, while the other is confirmed as the head of the inner subarray.

- Also, note that the inner subarray's starting location is not affected by the value of `prefix+suffix`, since its exclusion from it is conditioned by the rules that govern how items are added to either sum subarrays. It follows that only a single pass is necessary to calculate either minsum or maxsum and derive its counterpart.

Take for example the array `A = {-1, 3, -3, 9, -6, 8, -5, -5, -6, 10}`. As an ordinary array, its maxsum subarray goes from `A[3]` to `A[5]` inclusively and its minsum from `A[6]` to `A[8]`.

If `A` is made into a circular array, one of those two subarrays will be its inner subarray. The other will be made part of the `prefix+suffix` combo.

After testing the two, it turns out that `A[6]` to `A[8]` is the inner subarray. And since it's the minsum, it makes the subarray starting at location `A[9]` and circling back to connect to `A[5]` the actual maxsum of the circular array.

- Another way to observe the above relationship is to see that the respective minsum and maxsum subarrays only influence either local maxima or minima of other items, but not both. If `prefix+suffix` is a maxsum subarray, it will also impact the maxsum at index `A[6]` through `A[8]`, but it won't influence their minsum.
