### Definitions

Consider an array `A = {A[0], A[1], ..., A[N-1]}` such that two contiguous elements in `A` cannot have the same value. That is, the following is not possible:

    A = { ..., e, e, ... }

We'll note a slice in `A` going from index `i` to index `j` (inclusively) as `(i:j)`.

    A------------------------------------------------------------------+
    |                          (i:j)------------+                      |
    |                          |                |                      |
    {A[0], A[1], ...., A[i-1], (A[i], ...., A[j]), A[j+1], ...., A[N-1]}

Consider `P` the set of all slices `(i:j)` in `A` such that:
- the first item in the slice is greater than the one immediately preceding it in `A`: `A[i-1] < A[i]`.
- the last item in the slice is greater than the one immediately following it in `A`: `A[j] > A[j+1]`.

    A------------------------------------------------------------------+
    |                          (i:j)------------+                      |
    |                          |                |                      |
    {A[0], A[1], ...., A[i-1], (A[i], ...., A[j]), A[j+1], ...., A[N-1]}
                       A[i-1] <(A[i]        A[j])> A[j+1]

Noting that for all slices in `P`, `A[i-1] < (A[i] ... A[j]) > A[j+1]`, let's shorthand this property with the notation `<(i:j)>` and summarize a definition of `P` as the set of all slices of `A` of the form `<(i:j)>`.

As a corollary to that definition a slice `(u:v)` is excluded from `P` if:
- the first element in `(u:v)` is less than the item in `A` immediately preceding it: `A[u-1] > A[u]`, noted as `>(u:v)>`.
- or the last element in `(u:v)` is less than the item in `A` immediately following it: `A[v] < A[v+1]`, or `<(u:v)<`.
- or a combination of the above: `>(u:v)<`.

If `A` is padded with two pseudo elements at the *symbolic* indexes `-1` and `N`, such that its real first and last items, at indexes `0` and `N-1`, are greater than their respective symbolic predecessor and successor, the slice `(0:N-1)` itself becomes part of `P`.

            A = { -∞, (A[0], A[1], ...., A[N-1]), -∞ }
                  -∞ <(A[0]              A[N-1])> -∞

Or more succinctly, `<(0:N-1)>`.

### Proof that all slices in `P` have a discoverable peak
Observe that any singleton slice in `P`, denoted as `<(i:i)>`, marks a peak and by definition, all peaks are in `P`.

    A-------------------------------+
    |            (i:i)--+           |
    |            |      |           |
    {      ...   ( A[i] )   ...     }
        A[i-1] < ( A[i] ) > A[i+1]

Consider `<(i:j)>`, a slice of two items (a pair, i.e. `j = i+1`) in `P`. As per our constraint that two contiguous elements in `A` can't have the same value `A[i] <> A[j]`.

    A-----------------------------------+
    |         (i:j)--------+            |
    |         |            |            |
    {         ( A[i], A[j] )            }
     A[i-1] < ( A[i]  A[j] ) > A[j+1]


If `A[i] > A[j]`, then the pair can also be represented as two contiguous singletons `<(i:i)>(j:j)>`, where `<(i:i)>` belongs in `P` and `>(j:j)>` does not. Conversely, if `A[i] < A[j]` then `<(i:i)<(j:j)>` and `<(j:j)>` denotes a peak in `P`.

More generally, if we consider any two contiguous indexes `x` and `y` in a slice `<(i:j)>` in `P`,

           <(A[i], ..., A[x], A[y], ... A[j])>

if `A[x] > A[y]`, the split `x|y` results in two slices such that `<(i:x)>(y:j)>`, with `<(i:x)>` included in `P` and `>(y:j)>` excluded from `P`. And conversely, if `A[x] < A[y]` then `<(i:x)<` is excluded from `P`, while `<(y:j)>` is included.

We can generalize the observation: any slice in `P` can be split in two parts anywhere along its collection, resulting in one part belonging in `P` and the other excluded from `P`.

We can repeatedly split the resulting slices in `P` down to a singleton, thus eventually finding a peak.

We've proven that all slices in `P` have at least one discoverable peak, and by extension that any array that abides by the constraints laid out earlier also has at least one peak.

### Proof that the peak can be found in logarithmic time
If a slice in `P` can arbitrarily be split to produce a smaller slice that also belongs in `P`, then we can shrink the size of an arbitrarily large slice in `P` by half by splitting the slice at its midpoint. Repeating this process with the resulting slices eventualy yields a singleton slice. For a slice of size `N`, the peak can thus be reached after `Log(N)` splits.

### Algorithm
The algorithm hinges on the observation that splitting a slice of `P` in half, results in a shorter slice that also belongs in `P`.

We can calculate the midpoint of a slice `<(i:j)>` as `mp = floor((i+j)/2)`, thus placing `mp` on the low side of that divide (the algorithm can be adapted to be consistent with the `start:stop` convention. See next section), that is, as the last index of the resulting left slice, thus making `mp+1` the first index of the right slice.

    (i:j) = (i:mp) + (mp+1:j)

Which of the two halves is carried forward in `P` depends on which of `mp` or `mp+1` is greater.

    mp > mp+1 =>  <(i:mp)>(mp+1:j)> => <(i:mp)>
    mp < mp+1 =>  <(i:mp)<(mp+1:j)> => <(mp+1:j)>

The search ends when reaching a singleton slice, which happens when `i==j`.

```
find_peak(A) {
    i = 0
    j = A.size - 1
    while i!=j {            // while the first and last item aren't the same
        mp = (i+j)//2
        if A[mp] > A[mp+1]:
            j = mp
        else:               // A[mp] < A[mp+1]
            i = mp+1
    }
    return i
}
```

#### Adaptation to the `start:stop` convention
As a reminder a slice defined as `start:stop` means that the `stop` position is excluded from the collection. If we denote our slices above as `<(i:j)>`, it means that in our situation, `stop = j+1` and `mp = (start+stop)//2` thus implies `mp = (i+j+1)`, which places `mp` on the right side of the split, thus making the last item of the left side `mp-1`.

```
find_peak(A) {
    i = 0
    j = A.size - 1
    while i < j {           // while the first item is less than the last item
        mp = (i+j+1)//2
        if A[mp-1] > A[mp]:
            j = mp-1        // excludes mp
        else:               // A[mp-1] < A[mp]
            i = mp          // includes mp
    }
    return i
}
```

Or to make things simpler by excluding `j` altogether from the slice. 

```
find_peak(A) {
    i = 0
    j = A.size
    while j-i > 1 {         // while the slice is larger than 1
        mp = (i+j)//2
        if A[mp-1] > A[mp]:
            j = mp          // excludes mp
        else:               // A[mp-1] < A[mp]
            i = mp          // includes mp
    }
    return i
}
```
